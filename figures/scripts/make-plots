#!/usr/bin/env python3

import matplotlib.pyplot as plt
import numpy as np
import argparse
import colorsys
import h5py
import husl
import glob
import os
import pickle
from itertools import chain
from scipy import interpolate
from matplotlib import ticker
from matplotlib.colors import LinearSegmentedColormap
from matplotlib import patches
from matplotlib import gridspec

aspect = 1/1.618
resolution = 72.27
columnwidth = 246/resolution
textwidth = 510/resolution
textiny, texsmall, texnormal = 8.0, 9.25, 10.0
cm1, cm2 = plt.cm.Blues(.8), plt.cm.Reds(.8)
cv2, cv3, cv24, cv4 = plt.cm.Blues(.6), \
	plt.cm.Oranges(.6), plt.cm.Greens(.6), plt.cm.Reds(.6)
offblack = '#262626'
gray = '0.8'

plt.rcdefaults()
plt.rcParams.update({
	'font.family': 'sans-serif',
	'font.serif': ['CMU Serif'],
	'font.size': texsmall,
	'legend.fontsize': texsmall,
	'axes.labelsize': texsmall,
	'axes.titlesize': texsmall,
	'xtick.labelsize': textiny,
	'ytick.labelsize': textiny,
	'font.weight': 400,
	'axes.labelweight': 400,
	'axes.titleweight': 400,
	'lines.linewidth': .9,
	'lines.markersize': 3,
	'lines.markeredgewidth': .1,
	'patch.linewidth': .9,
	'axes.linewidth': .5,
	'xtick.major.width': .5,
	'ytick.major.width': .5,
	'xtick.minor.width': .5,
	'ytick.minor.width': .5,
	'xtick.major.size': 2,
	'ytick.major.size': 2,
	'xtick.minor.size': 1.3,
	'ytick.minor.size': 1.3,
	'xtick.major.pad': 1.8,
	'ytick.major.pad': 1.8,
	'text.color': 'black',
	'axes.edgecolor': 'black',
	'axes.labelcolor': 'black',
	'xtick.color': 'black',
	'ytick.color': 'black',
	'legend.numpoints': 1,
	'legend.scatterpoints': 1,
	'legend.frameon': False,
	'image.interpolation': 'none',
	'pdf.fonttype': 42,
})


plot_functions = {}


def plot(f):
	def wrapper(*args, **kwargs):
		print(f.__name__)
		f(*args, **kwargs)
		plt.savefig('{}.pdf'.format(f.__name__))
		plt.close()

	plot_functions[f.__name__] = wrapper

	return wrapper


def finish(despine=True, remove_ticks=False, pad=0.1, h_pad=None, w_pad=None,
		   rect=[0, 0, 1, 1]):
	fig = plt.gcf()

	for ax in fig.axes:
		if despine:
			for spine in 'top', 'right':
				ax.spines[spine].set_visible(False)

		if remove_ticks:
			for ax_name in 'xaxis', 'yaxis':
				getattr(ax, ax_name).set_ticks_position('none')
		else:
			ax.xaxis.set_ticks_position('bottom')
			ax.yaxis.set_ticks_position('left')

	fig.tight_layout(pad=pad, h_pad=h_pad, w_pad=w_pad, rect=rect)


def set_loc(ax, xy=None, nbins=5, steps=[1, 2, 3, 4, 5, 10],
			prune=None, minor=0):
	if xy == 'x':
		axes = ax.xaxis,
	elif xy == 'y':
		axes = ax.yaxis,
	else:
		axes = ax.xaxis, ax.yaxis

	for axis in axes:
		axis.set_major_locator(
			ticker.MaxNLocator(nbins=nbins, steps=steps, prune=prune)
		)
		if minor:
			axis.set_minor_locator(ticker.AutoMinorLocator(minor))


def desaturate(color, fraction=0.5):
	h, l, s = colorsys.rgb_to_hls(*color[:3])
	return colorsys.hls_to_rgb(h, l, fraction*s)


def recolor(color, f1=0.7, f2=0.7):
	h, l, s = colorsys.rgb_to_hls(*color[:3])
	return colorsys.hls_to_rgb(h, f1*l, f2*s)


def truncate_colormap(cmap, minval=0.0, maxval=1.0, n=100):
	new_cmap = LinearSegmentedColormap.from_list(
		'trunc({n},{a:.2f},{b:.2f})'.format(n=cmap.name, a=minval, b=maxval),
		cmap(np.linspace(minval, maxval, n)))
	return new_cmap


TRENTO_LABEL = r'T\raisebox{-.5ex}{R}ENTo'


def set_trento_label(legend, i):
	"""
	Mark the `i`th label of a legend as containing the T_RENTo logo.

	"""
	t = legend.get_texts()[i]
	t.set_usetex(True)
	t.set_y(-.18*t.get_size())
	return legend


@plot
def trento3d_example():
	fig, axes = plt.subplots(nrows=2, ncols=2,
							 figsize=(columnwidth, .7*columnwidth),
							 gridspec_kw=dict(height_ratios=[2, 1]))

	systems = 'PbPb.hdf5', 'pPb.hdf5'
	system_labels = 'Pb+Pb', 'p+Pb'
	event_indices = 5, 3
	grid_limits = 10, 10, 10
	x_labels = '$x$ [fm]', '$\eta_s$'

	cdict = plt.cm.PuBu._segmentdata.copy()
	cdict['red'][0] = (0, 1, 1)
	cdict['blue'][0] = (0, 1, 1)
	cdict['green'][0] = (0, 1, 1)
	my_cmap = LinearSegmentedColormap('blues2', cdict)

	for i, (system, event, system_label) \
			in enumerate(zip(systems, event_indices, system_labels)):
		for j, x_label in enumerate(x_labels):
			ax = axes[i, j]
			with h5py.File('data/trento-events/' + system, 'r') as f:
				ev = f['event_3d_{}'.format(event)]
				nx, ny, neta = ev.shape
				if j == 0:
					ev = ev[:, :, neta/2].T
				else:
					ev = ev[nx/2, :, :]

				x_max, y_max, eta_max = grid_limits
				y = np.linspace(-y_max, y_max, ny)

				if ax.is_last_col():
					x = np.linspace(-eta_max, eta_max, neta)
					ax.set_xlim(-eta_max, eta_max)
					ax.set_xticks(np.linspace(-8, 8, 5))
					ax.set_yticklabels([])
				else:
					x = np.linspace(-x_max, x_max, nx)
					ax.set_xlim(-x_max, x_max)
					ax.set_xticks(np.linspace(-8, 8, 5))

				if ax.is_last_row():
					ax.set_ylim(-5, 5)
					ax.set_yticks(np.linspace(-3, 3, 3))
					ax.set_title(system_label, x=.83, y=.88,
								 ha='center', va='top')
				else:
					ax.set_ylim(-x_max, x_max)
					ax.set_yticks(np.linspace(-8, 8, 5))
					ax.set_title(system_label, x=.83, y=.94,
								 ha='center', va='top')
					ax.set_xticklabels([])

				cs = ax.pcolorfast(x, y, ev, cmap=my_cmap)
				cs.set_clim(0., np.max(ev))

				ax.set_xlabel(x_label if i == 1 else '')
				ax.set_ylabel('$y$ [fm]' if j == 0 else '')
				ax.set_aspect('equal', adjustable='datalim')

	finish(h_pad=.6)


def dsdy(Ta, Tb, p, mu, sigma, gamma, K, model=1):
	g = 1380/0.973
	yb = g+np.sqrt(g**2-1.)
	N = 100
	n = np.arange(2*N+1)
	L = sigma*10./3.*2
	k = 2*np.pi*(n-N)/L
	y = 1.0*(n-N)/(2*N)*L
	mu0 = L/2.0
	norm = ((Ta**p + Tb**p)/2.)**(1./p)
	eta = np.arcsinh(np.sqrt(K)*np.sinh(y))
	mean = mu0 + (sigma*mu)*0.5*np.log((Ta*yb+Tb/yb)/(Ta/yb+Tb*yb))
	if model == 1:
		gamma = sigma**3*gamma*(Ta-Tb)/(Ta+Tb) * np.exp(-sigma**2*k**2/2.)
	else:
		gamma = sigma**3*gamma*(Ta-Tb) * np.exp(-sigma**2*k**2/2.)
	Fk = np.exp(1j*mean*k - 0.5 * sigma**2 * k**2 +
						1.0/6.0*gamma*1j*k**3)/np.sqrt(2*np.pi)*sigma
	J = K*np.cosh(eta)/np.sqrt(1.0 + (K*np.sinh(eta))**2)
	corr = np.exp(2*np.pi*1j*N*n/(2*N+1.))/np.pi/2.0
	Fy = np.real(np.multiply(np.fft.fft(Fk), corr))*J
	dNdeta = Fy/Fy[N]
	return eta, dNdeta*norm
@plot
def post_dsdy():
	f1 = h5py.File("data/design_and_posterior/result-rel.hdf5", 'r')
	f2 = h5py.File("data/design_and_posterior/result-abs.hdf5", 'r')
	ranges_I =  h5py.File("data/design_and_posterior/formal.hdf5",'r')['design_points'].attrs['range']
	chain_I = f1['pset'].value.T[:]
	chain_II = f2['pset'].value.T[:]
	chain_II[7] *= 0.36
	Ndim, Nsample = chain_I.shape
	for i in range(Ndim):
		chain_I[i] = chain_I[i]*(ranges_I[i][1]-ranges_I[i][0])\
			+ ranges_I[i][0]
		chain_II[i] = chain_II[i]*(ranges_I[i][1]-ranges_I[i][0])\
			+ ranges_I[i][0]

	p1 = []
	p2 = []
	for i in range(100):
		p = (chain_I.T[np.random.randint(0, Nsample,1)])[0]
		p1.append([p[2],p[-4],p[-3],p[-2],p[-1]])
		p = (chain_II.T[np.random.randint(0, Nsample,1)])[0]
		p2.append([p[2],p[-4],p[-3],p[-2],p[-1]])

	N = 3
	fig, axes = plt.subplots(ncols=N, nrows=N, sharex=True, sharey=True,
							 figsize=(columnwidth, columnwidth))
	x = np.linspace(0.2,2.4,N)	
	TB, TA = np.meshgrid(x,x)
	x = dsdy(1,1,*p1[0])[0]
	for ix, (ax, ta, tb) in enumerate(zip(axes.flatten(), TA.flatten(), TB.flatten())):
		
		for p, c, L, fmt, h in zip([p1, p2], [cm1, cm2], ['rel-skew', 'abs-skew'], ['-', '--'], ['', '/////']):
			y = [dsdy(ta, tb, *pi)[1] for pi in p]
			mean = np.mean(y, axis=0)
			std = np.std(y, axis=0)
			ax.plot(x, mean, fmt, color=c, alpha=1, label=L)
			ax.fill_between(x, mean-std, mean+std, edgecolor=c, facecolor=c if h=='' else 'none', alpha=0.35, hatch=h, linewidth=1)
		if ix%N == 2:
			ax.annotate(r'$T_A = {:1.1f}$'.format(ta)+' (fm${}^{-2}$)', xy=(1.04, 0.5), xycoords='axes fraction',
							 va='center', ha='left', rotation=-90,
							 fontsize=textiny*0.8)
		if ix < 3:
			ax.annotate(r'$T_B = {:1.1f}$'.format(tb)+' (fm${}^{-2})$', xy=(0.5, 1.0), xycoords='axes fraction',
							 va='bottom', ha='center', rotation=0,
							 fontsize=textiny*0.8)
		ax.set_xlim(-8,8)
		ax.set_yticks([])
	h, l = axes[0,0].get_legend_handles_labels()
	band0 = patches.Patch(color=cm1, alpha=0.4, lw=0, zorder=2)
	band1 = patches.Patch(edgecolor=cm2, facecolor='white', alpha=0.4, lw=0, zorder=2, hatch='////')
	leg = [[(h[0], band0), (h[1], band1)], [l[0], l[1]]]
	axes[0,0].legend(*leg, loc=(0.02, 0.5), fontsize=6)
	plt.subplots_adjust(wspace=0., hspace=0.)
	fig.text(0.5, 0.04, r'$\eta$', ha='center')
	fig.text(0.04, 0.5, r'$ds/d\eta$ (arb. units)', va='center', rotation='vertical')
	finish(pad=1, h_pad=0.5, w_pad=0.5, rect=[0.05, 0.04, 0.98, 0.98]) 
		

@plot
def posterior():
	f1 = h5py.File("data/design_and_posterior/result-rel.hdf5", 'r')
	f2 = h5py.File("data/design_and_posterior/result-abs.hdf5", 'r')
	chain_I = f1['pset'].value.T[:]
	chain_II = f2['pset'].value.T[:]
	chain_II[7] *= 0.36

	ranges_I =  h5py.File("data/design_and_posterior/formal.hdf5",'r')['design_points'].attrs['range']
	ranges_II = ranges_I*1.
	f1.close()
	f2.close()
	labels = [r"$N_{\mathrm{PbPb}}$", r"$N_{\mathrm{pPb}}$",
			  r"$p$", r"$k$", r"$w$", r"$\mu_0$", r"$\sigma_0$",
			  r"$\gamma_0$", "$J$"]
	ranges = ranges_I*1.
	ranges[1, :] = [150, 200]
	nxy = chain_II.shape[0]
	assert nxy == chain_I.shape[0]
	for i in range(nxy):
		chain_I[i] = chain_I[i]*(ranges_I[i][1]-ranges_I[i][0])\
			+ ranges_I[i][0]
		chain_II[i] = chain_II[i]*(ranges_II[i][1]-ranges_II[i][0])\
			+ ranges_II[i][0]

	chain_I[1] = chain_I[0]*chain_I[1]*0.8
	chain_II[1] = chain_II[0]*chain_II[1]*0.8
	chains = chain_I, chain_II
	def recolor(rgb):
		h, s, l = husl.rgb_to_husl(*rgb)
		return husl.husl_to_rgb(h, .75*s, min(1.02*l, 100))

	cmaps = [
		plt.cm.Blues,
		LinearSegmentedColormap.from_list(
			'Reds_mod',
			[recolor(rgba[:3]) for rgba in plt.cm.Reds(np.linspace(0, 1, 9))]
		),
	]

	fig, axes = plt.subplots(
		nrows=nxy, ncols=nxy,
		#sharex='col', sharey='row',
		figsize=(textwidth, textwidth)
	)
	def fmt_tick(n):
		s = str(float(n))
		if abs(n) > 10 and s.endswith('.0'):
			return s[:-2]
		return s
	for n, (ax, lim) in enumerate(zip(axes.diagonal(), ranges)):
		counts, edges = zip(*[
			np.histogram(c[n], bins=50, range=lim, density=True)
			for c in chains
		])

		assert np.allclose(edges[0], edges[1])
		edges = edges[0]
		x = (edges[1:] + edges[:-1]) / 2

		cmax = max(c.max() for c in counts)

		for c, cmap in zip(counts, cmaps):
			y = .84 * (lim[1] - lim[0]) * c / cmax + lim[0]
			ax.plot(x, y, lw=0.8, color=cmap(.8))
			ax.fill_between(
				x, lim[0], y, color=cmap(.5, alpha=0.2), zorder=-10
			)

		ticks = [lim[0],  lim[1]]

		ax.set_xlim(lim)
		ax.set_xticks(ticks if ax.is_last_row() else [])
		ax.set_xticklabels([fmt_tick(i) for i in ticks] \
						if ax.is_last_row() else [])
		ax.set_ylim(lim)
		ax.set_yticks([])
		ax.set_yticklabels([])



	for nyx in zip(*np.tril_indices_from(axes, k=-1)):		
		for c, cmap, (ny, nx) in zip(chains, cmaps, [nyx, reversed(nyx)]):
			ax = axes[ny][nx]
			H, xedges, yedges = np.histogram2d(
				c[nx], c[ny], bins=100, range=(ranges[nx], ranges[ny]),
			)
			H[H == 0] = None
			ax.pcolorfast(xedges, yedges, H.T, cmap=cmap)
			xlim = ranges[nx]
			ylim = ranges[ny]
			xticks = [xlim[0],  xlim[1]]
			yticks = [ylim[0],  ylim[1]]
			ax.set_xlim(xlim)
			ax.set_xticks(xticks if ax.is_last_row() else [])
			ax.set_xticklabels([fmt_tick(i) for i in xticks] \
							if ax.is_last_row() else [])
			ax.set_ylim(ylim)
			ax.set_yticks(yticks if ax.is_first_col() else [])
			ax.set_yticklabels([fmt_tick(i) for i in yticks] \
							if ax.is_first_col() else [])


	for n, label in enumerate(labels):
		axes[-1][n].set_xlabel(label)
		axes[n][0].set_ylabel(label)

		axes[0][n].annotate(label, xy=(0.5, 1.02), xycoords='axes fraction',
							va='bottom', ha='center', fontsize=texnormal)
		axes[n][-1].annotate(label, xy=(1.04, 0.5), xycoords='axes fraction',
							 va='center', ha='left', rotation=-90,
							 fontsize=texnormal)

		for t, justify in zip(axes[-1][n].xaxis.get_major_ticks(),
							  ['left', 'center', 'right']):
			t.label1.set_horizontalalignment(justify)
		for t, justify in zip(axes[n][0].yaxis.get_major_ticks(),
							  ['bottom', 'center', 'top']):
			t.label1.set_verticalalignment(justify)
	finish(pad=1, h_pad=0.5, w_pad=0.5, rect=[0., 0., 0.98, 0.98]) 

@plot
def post_obs():

	fig, axes = plt.subplots(nrows=1, ncols=3,
							 figsize=(textwidth, 0.8*columnwidth))

	f_exp = h5py.File('data/complete-exp/exp-data.hdf5', 'r')
	f1 =  h5py.File('data/design_and_posterior/result-rel.hdf5', 'r')
	f2 =  h5py.File('data/design_and_posterior/result-abs.hdf5', 'r')
	#-----------pPb data----------------------------
	exp_pPb = np.array( [f_exp['pPb']['cen-%d'%c]['dNdy'].value for c in range(8)] )
	err_pPb = np.array( [f_exp['pPb']['cen-%d'%c]['syserr'].value for c in range(8)] )
	exp_PbPb = np.array( [f_exp['PbPb']['cen-%d'%c]['dNdy'].value for c in range(10)] )
	err_PbPb = np.array( [f_exp['PbPb']['cen-%d'%c]['syserr'].value for c in range(10)] )
	xL_a1, xH_a1, exp_a1, err_a1 = np.loadtxt('data/complete-exp/data-atlas-a1.dat')[:].T
	x_a1 = 0.5*(xL_a1+xH_a1)

	expcolor = 'gray'
	c = [cm1, cm2]
	fc = [cm1, '']
	ha = ['', "||"]
	alpha = [0.5, 0.8]
	model = ['rel-skew', 'abs-skew']
	ms=2

	x = np.linspace(-4.75, 4.75, 40)
	dx = x[1]-x[0]
	for i in range(10):
		for j, (xx, yy, err) in enumerate(zip(x, exp_PbPb[i], err_PbPb[i])):
			axes[0].plot(xx, yy, 'D',color=expcolor, alpha=1, markersize=ms, label="ALICE, 2.76 TeV" if i==0 and j==0 else '')
			axes[0].fill_between([xx-dx*0.5, xx+dx*0.5],[yy-err, yy-err],[yy+err, yy+err], color=expcolor, alpha=0.5, linewidth=0.)
	for k, f in enumerate([f1, f2]):
		dNdy = f['post-PbPb'].value.reshape(100, 10, 40)
		for i in range(10):
			dndy = dNdy[:,i,:]
			mean = np.mean(dndy, axis=0)
			std = np.std(dndy, axis=0)
			axes[0].fill_between(x, mean-2.*std, mean+2.*std, edgecolor=c[k], facecolor=fc[k], alpha=alpha[k], hatch=ha[k])
	axes[0].set_xlabel(r'$\eta$')
	axes[0].set_ylabel(r'$dN/d\eta$')
	axes[0].set_ylim(0,2000)
	band0 = patches.Patch(color='gray', alpha=0.5, lw=0, zorder=2)
	h, l = axes[0].get_legend_handles_labels()
	leg = [[(h[0], band0)], [l[0]]]
	axes[0].legend(*leg, loc='upper left', fontsize=textiny)

	x = np.linspace(-2.65, 2.65, 54)
	dx = x[1]-x[0]
	for i in range(8):
		for j, (xx, yy, err) in enumerate(zip(x, exp_pPb[i], err_pPb[i])):
			axes[1].plot(xx, yy, 'D',color=expcolor, alpha=1, markersize=ms, label="ATLAS, 5.02 TeV" if i==0 and j==0 else '')
			axes[1].fill_between([xx-dx*0.5, xx+dx*0.5],[yy-err, yy-err],[yy+err, yy+err], color=expcolor, alpha=0.5, linewidth=0.)

	for k, f in enumerate([f1, f2]):
		dNdy = f['post-pPb'].value.reshape(100, 8, 54)
		for i in range(8):
			dndy = dNdy[:,i,:]
			mean = np.mean(dndy, axis=0)
			std = np.std(dndy, axis=0)
			axes[1].fill_between(x, mean-2.*std, mean+2.*std, edgecolor=c[k], facecolor=fc[k], alpha=alpha[k], hatch=ha[k])
	axes[1].set_xlabel(r'$\eta$')
	axes[1].set_ylabel(r'$dN/d\eta$')
	axes[1].set_ylim(0.0,85)
	band0 = patches.Patch(color='gray', alpha=0.5, lw=0, zorder=2)
	h, l = axes[1].get_legend_handles_labels()
	leg = [[(h[0], band0)], [l[0]]]
	axes[1].legend(*leg, loc='upper right', fontsize=textiny)

	
	# load calculation
	with open("./data/rel-full-results/multiplicity.pkl", 'rb') as f:
		results = pickle.load(f)
		cen = results['rms(a1)']['cen']
		ha11 = results['rms(a1)']['y'] #[cen, eta, n]
	with open("./data/abs-full-results/a1.pkl", 'rb') as f:
		results = pickle.load(f)
		ha12 = results['rms(a1)']['y'] #[cen, eta, n]	
	dx = 5
	for j, (xx, yy, err) in enumerate(zip(x_a1, exp_a1, err_a1)):
		axes[2].plot(xx, yy, 'D',color=expcolor, alpha=1, markersize=ms, label=r"ATLAS, $p_T > 0.5$ GeV" if j==0 else '')
		axes[2].fill_between([xx-dx*0.5, xx+dx*0.5],[yy-err, yy-err],[yy+err, yy+err], color=expcolor, alpha=0.5, linewidth=0.)
	for k, f in enumerate([f1, f2]):
		a1 = f['post-a1'].value
		mean = np.mean(a1, axis=0)
		std = np.std(a1, axis=0)
		axes[2].fill_between(x_a1[:-1], mean-2.*std, mean+2.*std, edgecolor=c[k], facecolor=fc[k], alpha=alpha[k], hatch=ha[k], label=model[k])

	axes[2].plot(cen, ha11, '-', color=c[0], label='rel-skew + vis Hybrid')	
	axes[2].plot(cen, ha12, '--', color=c[1], label='abs-skew + vis Hybrid')	

	axes[2].set_xlabel("Centrality (%)")
	axes[2].set_ylabel(r'$\sqrt{\langle a_{1}^2\rangle}$')
	axes[2].set_ylim(0.0,0.35)
	#axes[2].set_yscale("log", nonposy='clip')


	band0 = patches.Patch(color='gray', alpha=0.5, lw=0, zorder=2)
	h, l = axes[2].get_legend_handles_labels()
	leg = [[(h[0], band0), h[1], h[2], h[3], h[4]], [l[0], l[1], l[2], l[3], l[4]]]
	axes[2].legend(*leg, loc='upper left', fontsize=textiny)
	
	plt.subplots_adjust(wspace=0.07)
	finish(h_pad=0.5, w_pad=0.5, rect=(0, 0, 1, 1))
	f1.close()
	f2.close()

@plot
def regulate():
	"""
	N: half eta grid
	n: full eta grid
	L: 2*y_max
	k: wave vector of rapidity
	y: rapidity
	mu: mean
	sigma: standard deviation
	K: Jacobian
	norm: overall normalization
	Gamma: skewness
	"""
	N = 100
	n = np.arange(2*N+1)
	sigma = 3.
	L = sigma*10./3.*2
	k = 2*np.pi*(n-N)/L
	y = 1.0*(n-N)/(2*N)*L
	mu = L/2.0

	K = 0.7
	norm = 50.0
	normalized_gamma = np.linspace(0., 9.,  4)
	Gamma_list = [normalized_gamma*sigma**3, normalized_gamma*sigma**3]
	eta = np.arcsinh(np.sqrt(K)*np.sinh(y))

	colors = plt.cm.PuBu(np.linspace(0.5, 1, 4))
	line = ['-', '--', '-.', ':']
	titles = 'Unregulated', 'Regulated'

	fig, axes = plt.subplots(ncols=2, sharey=True,
							 figsize=(columnwidth, aspect*columnwidth))

	for ax, Gamma, title in zip(axes, Gamma_list, titles):
		for i in range(len(Gamma)):
			if ax.is_last_col():
				gamma = Gamma[i] * np.exp(-sigma**2*k**2/2.)
			else:
				gamma = Gamma[i] * np.ones_like(k)
			Fk = np.exp(1j*mu*k - 0.5 * sigma**2 * k**2 +
						1.0/6.0*gamma*1j*k**3)/np.sqrt(2*np.pi)*sigma
			J = K*np.cosh(eta)/np.sqrt(1.0 + (K*np.sinh(eta))**2)
			corr = np.exp(2*np.pi*1j*N*n/(2*N+1))/np.pi/2.0
			Fy = np.real(np.multiply(np.fft.fft(Fk), corr))*J
			dNdeta = norm*Fy/Fy[N]
			ax.plot(eta, dNdeta, line[i], color=colors[i],
					label='$\gamma={:.1f}$'.format(normalized_gamma[i]) if
					ax.is_last_col() else '')

		if ax.is_first_col():
			ax.set_ylabel(r'$dN_\mathrm{ch}/d\eta$ (arb. units)')
		else:
			ax.legend(loc='upper center', ncol=2, handletextpad=0.3,
					  columnspacing=1, handlelength=1.2, labelspacing=0.1,
					  fontsize=textiny)
		ax.axis([-10, 10, -30, 150])
		ax.set_xticks([-8, -4, 0, 4, 8])
		ax.axhline(y=0, lw=.5, color=offblack)
		ax.set_xlabel(r'$\eta$')
		ax.set_title(title, va='top')

	finish()

@plot
def evt_pln_decorr_far():
	fig, axes = plt.subplots(nrows=3, ncols=2, sharex=True, sharey=True,
							 figsize=(0.47*textwidth, 0.7*textwidth))
	# load experimental data
	labels = '0-5%', '5-10%', '10-20%', '20-30%', '30-40%', '40-50%'
	x_exp2, y_exp2, dy_exp2 = [], [], []
	x_exp3, y_exp3, dy_exp3 = [], [], []
	for i, label in enumerate(labels):
		ds = np.loadtxt("data/complete-exp/CMS-rn/r2-far/"+label[:-1]).T
		x_exp2.append(ds[0])
		y_exp2.append(ds[3])
		dy_exp2.append(ds[4])
		ds = np.loadtxt("data/complete-exp/CMS-rn/r3-far/"+label[:-1]).T
		x_exp3.append(ds[0])
		y_exp3.append(ds[3])
		dy_exp3.append(ds[4])
	

	# load calculation
	with open("./data/rel-full-results/rn-avg.pkl", 'rb') as f:
		results = pickle.load(f)
		cen = results['rn-1']['cen']
		eta = results['rn-1']['eta']
		rn_calc1 = results['rn-1']['y'] #[cen, eta, n]
		ern_calc1 = results['rn-1']['e'] #[cen, eta, n]

	with open("./data/abs-full-results/rn-avg.pkl", 'rb') as f:
		results = pickle.load(f)
		rn_calc2 = results['rn-1']['y'] #[cen, eta, n]
		ern_calc2 = results['rn-1']['e'] #[cen, eta, n]
	
	# loop over subplot panels
	for i, (ax, label) in enumerate(zip(axes.flat, labels)):

		# plot experimental data
		ax.errorbar(x_exp2[i], y_exp2[i], yerr=dy_exp2[i], fmt='o', mew=0.5,
					mec=offblack, capsize=0, c=cv2, ecolor=offblack,
					label='CMS $r_2$', clip_on=False, zorder=2, ms=2.5)
		ax.errorbar(x_exp3[i], y_exp3[i], yerr=dy_exp3[i], fmt='D', mew=0.5,
					mec=offblack, capsize=0, c=cv3, ecolor=offblack,
					label='CMS $r_3$', clip_on=False, zorder=2, ms=2.5)

		# plot model calc with error
		cv = [cv2, cv3]
		x = np.insert(eta, 0, 0.)
		fmt = ['-', '-'], ['--', '--']
		model = ['rel-skew', 'abs-skew']
		for im, (rn_calc, ern_calc) in enumerate([(rn_calc1, ern_calc1),
													(rn_calc2, ern_calc2)]):
			for n in range(2):
				y = np.insert(rn_calc[i].T[n],0,1.)
				dy = np.insert(ern_calc[i].T[n],0,0.)
				ax.plot(x, y, fmt[im][n], c=cv[n], label=model[im]+r' $ r_{}$'.format(n+2), zorder=1)
				ax.fill_between(x, y - dy, y + dy,
								hatch='||||' if im==1 else '',
								edgecolor=cv[n], alpha=0.4, 
								facecolor=cv[n] if im==0 else '', 
								lw=0, zorder=1)

		if ax.is_last_row():
			ax.set_xlabel(r"$\eta^a$")
		if ax.is_first_col():
			ax.set_ylabel(r"$r_n(\eta^a, \eta^b)$")
		ax.annotate(label, xy=(0.5, 1), xycoords='axes fraction',
					ha='center', va='center', clip_on=False)

	# legend
	
	band0 = patches.Patch(facecolor=cv2, edgecolor=cv2, alpha=0.4, lw=0, zorder=2)
	band1 = patches.Patch(facecolor='white', edgecolor=cv3, alpha=0.4, lw=0, zorder=2, hatch='||||')
	h, l = plt.gca().get_legend_handles_labels()
	lega = [h[4], h[5]], [l[4], l[5]],
	legc = [(h[2], band0), (h[3], band1)], [l[2], l[3]]
	legb = [(h[0], band0), (h[1], band1)], [l[0], l[1]]
	for ax, leg in zip(axes[:, 0], [lega, legb, legc]):
		ax.legend(*leg, bbox_to_anchor=(0, -0.05), loc='lower left',
				  columnspacing=0.2,  handlelength=1.5, handletextpad=0.4,
				  fontsize=textiny, labelspacing=0.4)

	plt.xlim(0.0, 2.4)
	plt.xticks([0, 1, 2])
	plt.ylim(0.75, 1.05)
	plt.yticks([0.8, 0.9, 1])
	plt.suptitle(r'$4.4 < |\eta^b| < 5.0$')
	finish(h_pad=1, rect=(0, 0, 1, 0.9))

@plot
def evt_pln_decorr_near():
	fig, axes = plt.subplots(nrows=3, ncols=2, sharex=True, sharey=True,
							 figsize=(0.47*textwidth, 0.7*textwidth))
	# load experimental data
	labels = '0-5%', '5-10%', '10-20%', '20-30%', '30-40%', '40-50%'
	x_exp2, y_exp2, dy_exp2 = [], [], []
	x_exp3, y_exp3, dy_exp3 = [], [], []
	for i, label in enumerate(labels):
		ds = np.loadtxt("data/complete-exp/CMS-rn/r2-near/"+label[:-1]).T
		x_exp2.append(ds[0])
		y_exp2.append(ds[3])
		dy_exp2.append(ds[4])
		ds = np.loadtxt("data/complete-exp/CMS-rn/r3-near/"+label[:-1]).T
		x_exp3.append(ds[0])
		y_exp3.append(ds[3])
		dy_exp3.append(ds[4])
	

	# load calculation
	with open("./data/rel-full-results/rn-avg.pkl", 'rb') as f:
		results = pickle.load(f)
		cen = results['rn-0']['cen']
		eta = results['rn-0']['eta']
		rn_calc1 = results['rn-0']['y'] #[cen, eta, n]
		ern_calc1 = results['rn-0']['e'] #[cen, eta, n]

	with open("./data/abs-full-results/rn-avg.pkl", 'rb') as f:
		results = pickle.load(f)
		rn_calc2 = results['rn-0']['y'] #[cen, eta, n]
		ern_calc2 = results['rn-0']['e'] #[cen, eta, n]
	
	# loop over subplot panels
	for i, (ax, label) in enumerate(zip(axes.flat, labels)):

		# plot experimental data
		ax.errorbar(x_exp2[i], y_exp2[i], yerr=dy_exp2[i], fmt='o', mew=0.5,
					mec=offblack, capsize=0, c=cv2, ecolor=offblack,
					label='CMS $r_2$', clip_on=False, zorder=2, ms=2.5)
		ax.errorbar(x_exp3[i], y_exp3[i], yerr=dy_exp3[i], fmt='D', mew=0.5,
					mec=offblack, capsize=0, c=cv3, ecolor=offblack,
					label='CMS $r_3$', clip_on=False, zorder=2, ms=2.5)

		# plot model calc with error
		cv = [cv2, cv3]
		x = np.insert(eta, 0, 0.)
		fmt = ['-', '-'], ['--', '--']
		model = ['rel-skew', 'abs-skew']
		for im, (rn_calc, ern_calc) in enumerate([(rn_calc1, ern_calc1),
													(rn_calc2, ern_calc2)]):
			for n in range(2):
				y = np.insert(rn_calc[i].T[n],0,1.)
				dy = np.insert(ern_calc[i].T[n],0,0.)
				ax.plot(x, y, fmt[im][n], c=cv[n], label=model[im]+r' $ r_{}$'.format(n+2), zorder=1)
				ax.fill_between(x, y - dy, y + dy,
								hatch='|||||' if im==1 else '',
								edgecolor=cv[n], alpha=0.4, 
								facecolor=cv[n] if im==0 else '', 
								lw=0, zorder=1)

		if ax.is_last_row():
			ax.set_xlabel(r"$\eta^a$")
		if ax.is_first_col():
			ax.set_ylabel(r"$r_n(\eta^a, \eta^b)$")
		ax.annotate(label, xy=(0.5, 1), xycoords='axes fraction',
					ha='center', va='center', clip_on=False)

	# legend
	
	band0 = patches.Patch(facecolor=cv2, edgecolor=cv2, alpha=0.4, lw=0, zorder=2)
	band1 = patches.Patch(facecolor='white', edgecolor=cv3, alpha=0.4, lw=0, zorder=2, hatch='||||')
	h, l = plt.gca().get_legend_handles_labels()
	lega = [h[4], h[5]], [l[4], l[5]],
	legc = [(h[2], band0), (h[3], band1)], [l[2], l[3]]
	legb = [(h[0], band0), (h[1], band1)], [l[0], l[1]]
	for ax, leg in zip(axes[:, 0], [lega, legb, legc]):
		ax.legend(*leg, bbox_to_anchor=(0, -0.05), loc='lower left',
				  columnspacing=0.2,  handlelength=1.5, handletextpad=0.4,
				  fontsize=textiny, labelspacing=0.4)

	plt.xlim(0.0, 2.4)
	plt.xticks([0, 1, 2])
	plt.ylim(0.75, 1.05)
	plt.yticks([0.8, 0.9, 1])
	plt.suptitle(r'$3.0 < |\eta^b| < 4.0$')
	finish(h_pad=1, rect=(0, 0, 1, 0.9))


def Integrated_flow(x2, x3, w):
	m2 = np.average(x2, weights=w, axis=0)
	m3 = np.average(x3, weights=w, axis=0)
	N = np.sum(w, axis=0)**2/np.sum(w**2, axis=0)
	var2 = np.average((x2-m2)**2, weights=w**2, axis=0)/(N - 1.0)
	var3 = np.average((x3-m3)**2, weights=w**2, axis=0)/(N - 1.0)
	flow2_mean = m2**0.5
	flow2_err = 0.5*(var2/m2)**0.5
	flow3_mean = m3**0.5
	flow3_err = 0.5*(var3/m3)**0.5

	return flow2_mean, flow2_err, flow3_mean, flow3_err


@plot
def vn_cen():
	# figure properties
	plt.figure(figsize=(columnwidth, 0.8*columnwidth))
	gs = gridspec.GridSpec(2, 1, height_ratios=[3, 1.2])
	ax0, ax1 = plt.subplot(gs[0]), plt.subplot(gs[1])

	# load experimental data
	files = np.sort(glob.glob('data/complete-exp/alice-vn-cen/alice-v*'))
	cen_alice = [np.loadtxt(f, usecols=(0,)) for f in files]
	vn_alice = [np.loadtxt(f, usecols=(3,)) for f in files]
	stat_alice = [np.loadtxt(f, usecols=(4,)) for f in files]
	sys_alice = [np.loadtxt(f, usecols=(6,)) for f in files]

	# plot experimental data
	symbols = 'o', 'D'
	labels = r'$v_2$', r'$v_3$'

	for cen_exp, vn_exp, stat_exp, sys_exp, symbol, label in \
			zip(cen_alice, vn_alice, stat_alice, sys_alice, symbols, labels):
		ax0.errorbar(cen_exp, vn_exp, yerr=stat_exp, fmt=symbol,
					 color=offblack, mew=0, capsize=0)
		[ax0.fill_between([x0, x1], [y0, y0], [y1, y1], color=gray, lw=0,
						  zorder=1)
		 for (x0, x1, y0, y1) in zip(cen_exp-1, cen_exp+1,
									 vn_exp-sys_exp, vn_exp+sys_exp)]
		ax0.annotate(label, xy=(cen_exp[-1] + 3, vn_exp[-1]), xycoords='data',
					 ha='left', va='center')

	# load calculation
	with open("./data/rel-full-results/flow-mid-ebe.pkl", 'rb') as f:
		results = pickle.load(f)
	cen = results['vn-cen']['cen']
	vn_calc_rel = results['vn-cen']['y'].T #[n=(2,3), cen=(...)]
	vn_errs_rel = results['vn-cen']['e'].T #[n=(2,3), cen=(...)]
	with open("./data/abs-full-results/vn-cen-ebe.pkl", 'rb') as f:
		results = pickle.load(f)
	cen = results['vn-cen']['cen']
	vn_calc_abs = results['vn-cen']['y'].T #[n=(2,3), cen=(...)]
	vn_errs_abs = results['vn-cen']['e'].T #[n=(2,3), cen=(...)]
	# plot calculation
	colors = cv2, cv3
	for cen_exp, vn, vn_err, color in \
			zip(cen_alice, vn_calc_rel, vn_errs_rel, colors):
		m = int(len(cen_exp))
		ax0.plot(cen[:m], vn[:m], c=color, zorder=0,
				label='rel-skew' if m > 6 else '')
		ax0.fill_between(cen[:m], vn[:m] - 2*vn_err[:m], vn[:m] + 2*vn_err[:m],
						 color=color, alpha=0.3, lw=0, zorder=0)

	for cen_exp, vn, vn_err, color in \
			zip(cen_alice, vn_calc_abs, vn_errs_abs, colors):
		m = int(len(cen_exp))
		ax0.plot(cen[:m], vn[:m],'--', c=color, zorder=0,
				label='abs-skew' if m > 6 else '')
		ax0.fill_between(cen[:m], vn[:m] - 2*vn_err[:m], vn[:m] + 2*vn_err[:m],
						 color=color, alpha=0.3, lw=0, zorder=0)
	ax0.legend(framealpha=0., loc=(0.03,0.75))
	# ratio plot
	ax1.axhspan(0.9, 1.1, color='0.92', lw=0, zorder=0)
	for cen_exp, vn_exp, vn1, vn2, color in \
			zip(cen_alice, vn_alice, vn_calc_rel, vn_calc_abs, colors):
		m = int(len(cen_exp))
		ax1.errorbar(cen_exp, vn1[:m]/vn_exp, color=color)
		ax1.errorbar(cen_exp, vn2[:m]/vn_exp, fmt='--', color=color)

	# figure properties
	ax0.axis([0, 82, 0, 0.125])
	ax0.set_ylabel(r"$v_n\{2\}$")
	ax0.set_xticklabels([])

	ax0.annotate('\n'.join(('ALICE Pb+Pb', '$\sqrt{s_\mathrm{NN}}=2.76$ TeV',
						   '$0.2 < p_T < 5$ GeV, $|\eta| < 0.8$')),
				 xy=(1, 0.05),
				 xycoords='axes fraction', ha='right', va='bottom',
				 multialignment='right', fontsize=textiny)
	ax1.axhline(y=1, color='0.5', lw=0.6, zorder=0)
	ax1.axis([0, 76, 0.8, 1.20])
	ax1.set_yticks([0.8, 1, 1.2])
	ax1.set_xlabel("Centrality (%)")
	ax1.set_ylabel(r"Calc./Exp.")
	
	finish()


@plot
def vn_eta():
	fig, axes = plt.subplots(nrows=3, ncols=3, sharex=True, sharey=True,
							 figsize=(0.8*textwidth, 0.65*textwidth))
	# load calculation
	#
	with open("./data/rel-full-results/data-obs", 'rb') as f:
		results = pickle.load(f)
	cen = results['vn-eta']['cen']
	cenbins = [0,5,10,20,30,40,50,60,70,80]
	eta_calc = results['vn-eta']['eta']
	vn_calc1 = results['vn-eta']['y'] #[cen, eta, n]
	evn_calc1 = results['vn-eta']['e'] #[cen, eta, n]
	vn4_calc1 = results['vn-eta']['y1'] #[cen, eta]
	evn4_calc1 = results['vn-eta']['e1'] #[cen, eta]
	#print(evn4_calc1)
	with open("./data/abs-full-results/data-obs", 'rb') as f:
		results = pickle.load(f)
	vn_calc2 = results['vn-eta']['y'] #[cen, eta, n]
	evn_calc2 = results['vn-eta']['e'] #[cen, eta, n]
	vn4_calc2 = results['vn-eta']['y1'] #[cen, eta]
	evn4_calc2 = results['vn-eta']['e1'] #[cen, eta]
	# experimental data
	exp_cen = [np.loadtxt(f) for f in
			   np.sort(glob.glob('data/complete-exp/alice-vn-eta/*.dat'))]
			   
	label = [r'ALICE $v_2\{2\}$', r'ALICE $v_3\{2\}$', 
			 r'ALICE $v_2\{4\}$', r'ALICE $v_4\{2\}$']
	shape = ['o', 'D', 'v', 's']
	ms = [2.7, 2.7, 2.7, 2.7]
	band = patches.Patch(color=gray, lw=0, zorder=2)
	
	b1 = patches.Patch(color=cv2, alpha=0.35, lw=0, zorder=2)
	b2 = patches.Patch(color=cv3, alpha=0.35, lw=0, zorder=2)
	b3 = patches.Patch(color=cv24, alpha=0.35, lw=0, zorder=2)
	for i, (ax, exp) in enumerate(zip(axes.flat, exp_cen)):
		eta = exp.T[0]
		eta_ = list(chain(*zip(eta - 0.25, eta + 0.25)))
		if i < 6:
			Nrange = 3
		elif i < 7:
			Nrange = 2
		elif i< 9:
			Nrange = 2
		for n in range(Nrange):
			y, ystat, ysys = exp.T[1+n*3], exp.T[2+n*3], exp.T[3+n*3]
			y_lo = list(chain(*zip(y - ysys, y - ysys)))
			y_hi = list(chain(*zip(y + ysys, y + ysys)))
			ax.fill_between(eta_, y_lo, y_hi, color=gray, lw=0)
			ax.errorbar(eta, y, yerr=ystat, fmt=shape[n], ms=ms[n], 
						c=offblack, mew=0,
						capsize=0, label=label[n], zorder=2)

		eta = eta_calc
		deta = (eta[1]-eta[0])/2.
		for fmt, vn_calc, evn_calc, mfc in [	('o', vn_calc1, evn_calc1, cv2),
										('o', vn_calc2, evn_calc2, 'none')]:
			v2 = vn_calc[i].T[0]
			dv2 = evn_calc[i].T[0]
			ax.plot(eta, v2, fmt,color=cv2, mfc=mfc, markeredgewidth=0.8, markersize=2.5, label=r'rel-skew $v_2\{2\}$' if mfc==cv2 else r'abs-skew $v_2\{2\}$', zorder=2)
			for ieta, iv2, idv2 in zip(eta, v2, dv2):
				ax.fill_between([ieta-deta, ieta+deta], [iv2-idv2, iv2-idv2], 
								[iv2+idv2, iv2+idv2], color=cv2,
								alpha=0.3, lw=0, zorder=2)

		for fmt, vn_calc, evn_calc, mfc in [	('D', vn_calc1, evn_calc1, cv3),
										('D', vn_calc2, evn_calc2, 'none')]:
			v3 = vn_calc[i].T[1]
			dv3 = np.min([evn_calc[i].T[1], [0.02]*20], axis=0)
			ax.plot(eta, v3, fmt,color=cv3, mfc=mfc, 
					markeredgewidth=0.8, markersize=2.5, label=r'rel-skew $v_3\{2\}$' if mfc==cv3 else r'abs-skew $v_3\{2\}$', zorder=2)
			for ieta, iv3, idv3 in zip(eta, v3, dv3):
				ax.fill_between([ieta-deta, ieta+deta], [iv3-idv3, iv3-idv3], 
								[iv3+idv3, iv3+idv3], color=cv3, 
								alpha=0.3, lw=0, zorder=2)
		
		if i<6 and i>0:	
			for fmt, vn_calc, evn_calc, mfc in [	('v', vn4_calc1, evn4_calc1, cv24),
											('v', vn4_calc2, evn4_calc2, 'none')]:
				v2 = vn_calc[i]
				dv2 = evn_calc[i]
				ax.plot(eta, v2, fmt, mfc=mfc, color=cv24, 
						markeredgewidth=0.8, markersize=2.5, label=r'rel-skew $v_2\{4\}$' if mfc==cv24 else r'abs-skew $v_2\{4\}$', zorder=2)
				for ieta, iv2, idv2 in zip(eta, v2, dv2):
					ax.fill_between([ieta-deta, ieta+deta], [iv2-idv2, iv2-idv2],
									[iv2+idv2, iv2+idv2], color=cv24, 
									alpha=0.3, lw=0, zorder=2)

		if ax.is_first_col():
			ax.set_ylabel(r"$v_n\{2\}$")
			ax.set_yticks(np.linspace(0, 0.08, 3))
		if ax.is_last_row():
			ax.set_xlabel(r"$\eta$")
			ax.set_xticks(np.linspace(-3, 3, 3))
		ax.set_xlim(-5, 5)
		ax.set_ylim(0, 0.1)
		ax.annotate('%d–%d%%' % (cenbins[i], cenbins[i+1]), xy=(0.5, 1),
					xycoords='axes fraction', ha='center', va='center',
					clip_on=False)
		
	h, l = axes[0, 1].get_legend_handles_labels()
	lega = [(band, h[6]), (band, h[7]), (band, h[8])], l[6:]
	legc = [(h[1], b1), (h[3], b2), (h[5], b3)], [l[1],l[3],l[5]]
	legb = [(h[0], b1), (h[2], b2), (h[4], b3)], [l[0],l[2],l[4]]
	for ax, leg in zip(axes[0, :], [lega, legb, legc]):
		ax.legend(*leg, fontsize=textiny,
				  loc=(0.16, 0.565), handlelength=1.5, labelspacing=0.2,
				  handletextpad=0.4)
	
	finish(h_pad=0.5, w_pad=0, rect=(0, 0, 1, 0.98))

@plot
def sigma_vn():
	fig, ax = plt.subplots(nrows=1, ncols=1, sharex=True, sharey=True,
							 figsize=(0.8*textwidth, 0.65*textwidth))
	# load calculation
	with open("./data/rel-full-results/flows-eta-ebe.pkl", 'rb') as f:
		results = pickle.load(f)
	cen = results['vn-eta']['cen']
	cenbins = [0,5,10,20,30,40,50,60,70,80]
	eta_calc = results['vn-eta']['eta']
	vn_calc1 = results['vn-eta']['y'] #[cen, eta, n]
	evn_calc1 = results['vn-eta']['e'] #[cen, eta, n]
	with open("./data/abs-full-results/vn-eta-ebe.pkl", 'rb') as f:
		results = pickle.load(f)
	vn_calc2 = results['vn-eta']['y'] #[cen, eta, n]
	evn_calc2 = results['vn-eta']['e'] #[cen, eta, n]
	vn4_calc2 = results['vn-eta']['y1'] #[cen, eta, n]
	evn4_calc2 = results['vn-eta']['e1'] #[cen, eta, n]
	# experimental data
	exp_cen = [np.loadtxt(f) for f in
			   np.sort(glob.glob('data/complete-exp/alice-vn-eta/*.dat'))]
			   
	for ic, c in zip([1, 3, 5], ['r', 'g', 'b']):
		exp = exp_cen[ic]
		eta = exp.T[0]
		v2 = exp.T[1]
		v24 = exp.T[7]
		exp_ratio = np.sqrt((v2**2-v24**2)/2.)/v2

		v2 = vn_calc2[ic].T[0]
		dv2 = evn_calc2[ic].T[0]
		v24 = vn4_calc2[ic]
		dv24 = evn4_calc2[ic]
		calc_ratio = np.sqrt((v2**2-v24**2)/2.)/v2
		ax.plot(eta_calc, calc_ratio, color=c, 
				label=r'abs-skew')
		ax.errorbar(eta, exp_ratio, color=c, fmt='D', yerr=0.)
	ax.set_xlabel(r"$\eta$")
	ax.set_ylabel(r"$\sigma_{v_2}/v_2\{2\}$")
	ax.axis([-5,5,0,1.])
	
	finish(h_pad=0.5, w_pad=0, rect=(0, 0, 1, 0.98))


@plot
def smn():
	plt.figure(figsize=(textwidth, 1.2*columnwidth))
	gs = gridspec.GridSpec(2, 2, height_ratios=[3, 3])
	ax1 = plt.subplot(gs[0]), plt.subplot(gs[1])
	ax2 = plt.subplot(gs[2]), plt.subplot(gs[3])
	c42a, c42b = plt.cm.PuBu([0.75, 0.5])
	c32a, c32b = plt.cm.YlGn([0.75, 0.5])

	exp = np.loadtxt("data/complete-exp/alice-smn/smn.dat").T
	xexp = exp[0]
	y32exp = exp[3]
	e32exp_bar = exp[4]
	e32exp_box = exp[6]
	y42exp = exp[8]
	e42exp_bar = exp[9]
	e42exp_box = exp[11]
	
	# load calculation
	with open("./data/rel-full-results/flow-corr-ebe.pkl", 'rb') as f:
		results = pickle.load(f)
	cen_M = results['Smn-Mid']['cen']
	ycalcM1 = results['Smn-Mid']
	ycalcFB1 = results['Smn-MFB']
	with open("./data/abs-full-results/smn-ebe.pkl", 'rb') as f:
		results = pickle.load(f)
	cen_M = results['Smn-Mid']['cen']
	ycalcM2 = results['Smn-Mid']
	ycalcFB2 = results['Smn-MFB']

	for im, (ycalcM, ycalcFB) in enumerate([(ycalcM1, ycalcFB1), 
											(ycalcM2, ycalcFB2)]):
		# SC(m, n) |\eta| < 0.8
		s42 = ycalcM['s42']['y']
		e42 = ycalcM['s42']['e']
		s32 = ycalcM['s32']['y']
		e32 = ycalcM['s32']['e']
		ax1[im].plot(cen_M, s42, color=c42a, label='Hybrid, $|\eta|<0.8$', zorder=1)
		ax1[im].plot(cen_M, s32, color=c32a, label='Hybrid, $|\eta|<0.8$', zorder=1)
		ax1[im].fill_between(cen_M, s42-e42, s42+e42, color=c42a, lw=0, alpha=0.4, zorder=1)
		ax1[im].fill_between(cen_M, s32-e32, s32+e32, edgecolor=c32a, lw=0, alpha=0.4, zorder=1, hatch='||||||', facecolor='white')

		# SC(m, n) 2.5 < |\eta| < 3.5
		s42f = ycalcFB['s42']['y']
		e42f = ycalcFB['s42']['e']
		s32f = ycalcFB['s32']['y']
		e32f = ycalcFB['s32']['e']
		ax1[im].plot(cen_M, s42f, dashes=(4, 1), color=c42b, linewidth=1.5,
				 label='Hybrid, $2.5<|\eta|<3.5$', zorder=0)
		ax1[im].plot(cen_M, s32f, dashes=(4, 1), color=c32b, linewidth=1.5,
				 label='Hybrid, $2.5<|\eta|<3.5$', zorder=0)
		ax1[im].fill_between(cen_M, s42f-e42f, s42f+e42f, edgecolor=c42b, lw=0, alpha=0.4, zorder=0)
		ax1[im].fill_between(cen_M, s32f-e32f, s32f+e32f, edgecolor=c32b, lw=0, alpha=0.4, zorder=0, hatch='||||||', facecolor='white')

		# ALICE SC(m, n) |\eta| < 0.8
		ax1[im].errorbar(xexp, y42exp, [e42exp_bar, e42exp_bar], fmt='o', c=offblack,
					 capsize=0, mew=0, label="ALICE $(m,n)=(4,2)$", zorder=3)
		ax1[im].errorbar(xexp, y32exp, [e32exp_bar, e32exp_bar], fmt='D', c=offblack,
					 capsize=0, mew=0, label="ALICE $(m,n)=(3,2)$", zorder=3)

		for i in range(len(xexp)):
			x = [xexp[i]-1, xexp[i]+1]
			yl = [y42exp[i]-e42exp_box[i], y42exp[i]-e42exp_box[i]]
			yh = [y42exp[i]+e42exp_box[i], y42exp[i]+e42exp_box[i]]
			ax1[im].fill_between(x, yl, yh, color=gray, lw=0, zorder=2)

			x = [xexp[i]-1, xexp[i]+1]
			yl = [y32exp[i]-e32exp_box[i], y32exp[i]-e32exp_box[i]]
			yh = [y32exp[i]+e32exp_box[i], y32exp[i]+e32exp_box[i]]
			ax1[im].fill_between(x, yl, yh, color=gray, lw=0, zorder=2)

		ax1[im].set_xlim(0, 66)
		ax1[im].set_ylim(-1.5e-6, 3e-6)
		ax1[im].set_yticks([-1.0e-6, 0.0e-6, 1.0e-6, 2.0e-6, 3e-6])
		ax1[im].set_ylabel(r"$SC(m,n)$")
		ax1[im].set_yticklabels([r"$-1$",r"$0$",r"$1$",r"$2$",r"$3\times10^{-6}$"])
		ax1[im].set_xticklabels([])
		ax1[im].yaxis.set_label_coords(-0.14, 0.5)
		if im == 0:
			ax1[im].set_title('Relative-skewness')
			h, l = ax1[im].get_legend_handles_labels()
			leg = [h[4], h[5]], [l[4], l[5]]
			ax1[im].legend(*leg, loc=(0.0, 0.6), columnspacing=0.2, handlelength=1.5,
					   handletextpad=0.4, fontsize=textiny, labelspacing=0.4)
			alice = '\n'.join(['ALICE, Pb+Pb, $\sqrt{s_\mathrm{NN}}=2.76$ TeV',
							   '$0.2<p_T<5.0$ GeV, $|\eta|<0.8$'])
			ax1[im].annotate(alice, xy=(0.04, 0.85), xycoords='axes fraction',
						 multialignment='left', ha='left', fontsize=textiny)
		else:
			ax1[im].set_title('Absolute-skewness')
	# normalized plot
	exp = np.loadtxt("data/complete-exp/alice-smn/nsmn.dat").T
	xexp = exp[0]
	y32exp = exp[3]
	e32exp_bar = exp[4]
	e32exp_box = exp[6]
	y42exp = exp[8]
	e42exp_bar = exp[9]
	e42exp_box = exp[11]


	# SCN(m, n) |\eta| < 0.8
	for im, (ycalcM, ycalcFB) in enumerate([(ycalcM1, ycalcFB1), 
											(ycalcM2, ycalcFB2)]):
		ns42 = ycalcM['ns42']['y'][:-1]
		ens42 = ycalcM['ns42']['e'][:-1]
		ns32 = ycalcM['ns32']['y'][:-1]
		ens32 = ycalcM['ns32']['e'][:-1]
		ax2[im].plot(
			cen_M[:-1], ns42, color=c42a, label='Hybrid, $|\eta|<0.8$', zorder=1
		)
		ax2[im].plot(
			cen_M[:-1], ns32, color=c32a, label='Hybrid, $|\eta|< 0.8$', zorder=1
		)
		ax2[im].fill_between(
			cen_M[:-1], ns42-ens42, ns42+ens42, color=c42a, lw=0, alpha=0.4,
			zorder=1
		)
		ax2[im].fill_between(
			cen_M[:-1], ns32-ens32, ns32+ens32, edgecolor=c32a, lw=0, alpha=0.4,
			zorder=1, hatch='||||||', facecolor="white"
		)

		# SCN(m, n) 2.5 < |\eta| < 3.5
		ns42f = ycalcFB['ns42']['y'][:-1]
		ens42f = ycalcFB['ns42']['e'][:-1]
		ns32f = ycalcFB['ns32']['y'][:-1]
		ens32f = ycalcFB['ns32']['e'][:-1]
		ax2[im].plot(
			cen_M[:-1], ns42f, color=c42b, dashes=(4, 1), linewidth=2.,
			label='Hybrid, $2.5<|\eta|< 3.5$', zorder=0
		)
		ax2[im].plot(
			cen_M[:-1], ns32f, color=c32b, dashes=(4, 1), linewidth=2.,
			label='Hybrid, $2.5 < |\eta| < 3.5$', zorder=0
		)
		ax2[im].fill_between(
			cen_M[:-1], ns42f-ens42f, ns42f+ens42f, color=c42b,
			alpha=0.4, lw=0, zorder=0
		)
		ax2[im].fill_between(
			cen_M[:-1], ns32f-ens32f, ns32f+ens32f, edgecolor=c32b,
			alpha=0.4, lw=0, zorder=0, hatch='||||||', facecolor='white'
		)

		# ALICE SCN(m, n) |\eta| < 0.8
		ax2[im].errorbar(
			xexp, y42exp, [e42exp_bar, e42exp_bar], fmt='o', mew=0, capsize=0, c=offblack,
			label=r"ALICE $SC(4,2)/\langle v_4^2\rangle\langle v_2^2\rangle$",
			zorder=3
		)
		ax2[im].errorbar(
			xexp, y32exp, [e32exp_bar, e32exp_bar], fmt='D', mew=0, capsize=0, c=offblack,
			label=r"ALICE $SC(3,2)/\langle v_3^2\rangle\langle v_2^2\rangle$",
			zorder=3
		)

		for i in range(len(xexp)):
			x = [xexp[i]-1, xexp[i]+1]
			yl = [y42exp[i]-e42exp_box[i], y42exp[i]-e42exp_box[i]]
			yh = [y42exp[i]+e42exp_box[i], y42exp[i]+e42exp_box[i]]
			ax2[im].fill_between(x, yl, yh, color=gray, lw=0, zorder=2)

			x = [xexp[i]-1, xexp[i]+1]
			yl = [y32exp[i]-e32exp_box[i], y32exp[i]-e32exp_box[i]]
			yh = [y32exp[i]+e32exp_box[i], y32exp[i]+e32exp_box[i]]
			ax2[im].fill_between(x, yl, yh, color=gray, lw=0, zorder=2)

		ax2[im].set_xlim(0, 66)
		ax2[im].set_ylim(-0.3, 1.2)
		ax2[im].set_yticks([-0.3, 0.0, 0.5, 1.0])
		ax2[im].set_xlabel("Centrality (%)")
		ax2[im].set_ylabel(r"$SC(m,n)/\langle v_m^2\rangle\langle v_n^2\rangle$")

		if im == 0:
			band0 = patches.Patch(color=c42a, alpha=0.4, lw=0, zorder=2)
			band1 = patches.Patch(edgecolor=c32a, facecolor='white', alpha=0.4, lw=0, zorder=2, hatch='||||||')
			band2 = patches.Patch(color=c42b, alpha=0.4, lw=0, zorder=2)
			band3 = patches.Patch(edgecolor=c32b, facecolor='white', alpha=0.4, lw=0, zorder=2, hatch='||||||')

			h, l = ax2[im].get_legend_handles_labels()
			leg = [[(h[0], band0), (h[2], band2), (h[1], band1), (h[3], band3)],
				   [l[0], l[2], l[1], l[3]]]
			ax2[im].legend(*leg, loc=(0.02, 0.6), columnspacing=0.2,  handlelength=1.5,
					   handletextpad=0.4, fontsize=textiny, labelspacing=0.4)

	finish(h_pad=0.5, w_pad=0, rect=(0, 0, 1, 0.98))


def main():
	parser = argparse.ArgumentParser()
	parser.add_argument('plots', nargs='*')
	args = parser.parse_args()

	if args.plots:
		for i in args.plots:
			if i.endswith('.pdf'):
				i = i[:-4]
			if i in plot_functions:
				plot_functions[i]()
			else:
				print('unknown plot:', i)
	else:
		for f in plot_functions.values():
			f()


if __name__ == "__main__":
	main()
